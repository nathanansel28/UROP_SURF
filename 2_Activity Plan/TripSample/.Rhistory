myforecast
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
#Store the series in time series
tsdata<-ts(g_stock_sel,frequency = 25)
ddata<-decompose(tsdata,"multiplicative")
plot(ddata)
mymodel<-auto.arima(g_stock_sel)
mymodel
plot.ts(mymodel$residuals)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
myforecast
# Load required libraries
library(quantmod)
library(xts)
library(forecast)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
library(quantmod)
library(xts)
library(forecast)
library(ggplot2)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
# Combine historical data and forecast data into one data frame
combined_data <- data.frame(Date = index(g_stock_sel), Price = coredata(g_stock_sel))
combined_data <- rbind(combined_data, forecast_data)
library(quantmod)
library(xts)
library(forecast)
library(ggplot2)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
# Combine historical data and forecast data into one data frame
combined_data <- data.frame(Date = index(g_stock_sel), Price = coredata(g_stock_sel))
combined_data <- rbind(combined_data, forecast_data)
library(quantmod)
library(xts)
library(forecast)
library(ggplot2)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with forecast dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Convert Date to a Date class for proper plotting
forecast_data$Date <- as.Date(forecast_data$Date)
# Combine historical data and forecast data into one data frame
combined_data <- data.frame(Date = index(g_stock_sel), Price = coredata(g_stock_sel))
combined_data <- rbind(combined_data, forecast_data)
plot(myforecast)
plot(myforecast)
# Load required libraries
library(quantmod)
library(xts)
library(forecast)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
# Load required libraries
library(quantmod)
library(xts)
library(forecast)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
# Load required libraries
library(quantmod)
library(xts)
library(forecast)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('AAPL', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
# Load required libraries
library(quantmod)
library(xts)
library(forecast)
# Set the start and end dates for historical data
start_date <- as.Date("2017-01-01")
end_date <- as.Date("2023-07-10")
# Fetch historical data for the stock (TSLA in this example)
g_stock <- getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
# Extract the desired stock data (e.g., column 6 in this case)
g_stock_sel <- g_stock[, 6]
# Fit an ARIMA model to the data
mymodel <- auto.arima(g_stock_sel)
# Set the start and end date for the forecast range
start_forecast_date <- as.Date("2023-06-01")
end_forecast_date <- as.Date("2023-07-25")
# Create a sequence of dates for the forecast range
forecast_dates <- seq(start_forecast_date, end_forecast_date, by = "day")
# Number of days in the forecast range
num_days_forecast <- length(forecast_dates)
# Make the forecast for the specified date range
my_forecast_range <- forecast(mymodel, level = c(95), h = num_days_forecast)
# Extract forecasted values for the specified date range
forecasted_values <- my_forecast_range$mean
# Extract lower and upper bounds for the specified date range
lower_bound <- my_forecast_range$lower[, "95%"]
upper_bound <- my_forecast_range$upper[, "95%"]
# Create a data frame with dates and forecasted values
forecast_data <- data.frame(Date = forecast_dates, Forecast = forecasted_values,
LowerBound = lower_bound, UpperBound = upper_bound)
# Print the forecast data frame
print(forecast_data)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
write.csv(forecase_data, file = "dataframe.csv", row.names = FALSE)
write.csv(forecast_data, file = "dataframe.csv", row.names = FALSE)
N = 1000
xmin = 20; xmax = 120
set.seed(10)
xvec = runif(N, xmin, xmax)
slope =2; yintercept = 30
sdev =25
yvec = slope*xvec +yintercept + rnorm(N,0, sdev)
mygraph = function (xvec, yvec, n) {
N = length(xvec)
ivec = sample(1:N, n)
xvec2 = xvec[ivec]
yvec2 = yvec[ivec]
plot(xvec2, yvec2)
myline(xvec2,yvec2)
}
myline = function (xvec2, yvec2) {
#  source('./util.R')
n = length(xvec2); # = length(yvec2)
xbar = mean(xvec2)
ybar = mean(yvec2)
sxy = sum((xvec2-xbar)*(yvec2 - ybar))
sxx = sum((xvec2-xbar)^2)
b = sxy/sxx
a = ybar - b*xbar
cat("Slope=", b, "\n")
cat("Intercept=", a, '\n')
abline(b=b, a=a, col = 'red')
abline(b=slope, a = yintercept, col = "blue")
}
options(repr.plot.width = 10, repr.plot.height = 6)
par(mfrow = c(1,2))
mygraph(xvec, yvec, 40)
library(quantmod)
library(xts)
library(ggplot2)
library(gridExtra)
library(tseries)
library(forecast)
# How to install packages
# install.packages("xts")
# install.packages("ggplot2")
# install.packages("gridExtra")
# install.packages("tseries")
# install.packages("forecast")
graphics.off()
rm(list=ls())
#Data Range
start_date<-as.Date("2017-01-01")
end_date<-as.Date("2023-07-10")
g_stock = getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
#Store the series in time series
tsdata<-ts(g_stock_sel,frequency = 25)
ddata<-decompose(tsdata,"multiplicative")
plot(ddata)
mymodel<-auto.arima(g_stock_sel)
mymodel
plot.ts(mymodel$residuals)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
myforecast
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
#Store the series in time series
tsdata<-ts(g_stock_sel,frequency = 25)
ddata<-decompose(tsdata,"multiplicative")
plot(ddata)
mymodel<-auto.arima(g_stock_sel)
mymodel
plot.ts(mymodel$residuals)
myforecast<-forecast(mymodel,level=c(95),h=30)
plot(myforecast)
myforecast
g_stock = getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
g_stock
g_stock_return
start_date<-as.Date("2017-01-01")
end_date<-as.Date("2023-07-10")
g_stock = getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
g_stock
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
start_date<-as.Date("2017-01-01")
end_date<-as.Date("2023-07-10")
g_stock = getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
g_stock
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
write.csv(forecast_data, file = "forecast_1.csv", row.names = FALSE)
g_stock_return
start_date<-as.Date("2017-01-01")
end_date<-as.Date("2023-07-10")
g_stock = getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
g_stock
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
write.csv(g_stock_return, file = "forecast_1.csv", row.names = FALSE)
merge(g_stock_return, date)
print(g_stock_return)
data1 <- as.data.frame(g_stock_return)
data1
write.csv(data1, file = "forecast_2.csv", row.names = FALSE)
data1
data1[,1]
g_stock_return
start_date<-as.Date("2023-01-01")
end_date<-as.Date("2023-07-10")
g_stock = getSymbols('TSLA', from = start_date, to = end_date, auto.assign = FALSE)
g_stock
no.na<-which(is.na(g_stock[,6]))
g_stock[no.na,6]<g_stock[no.na-1,6]
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
print(g_stock_return)
install.packages("xts")
install.packages("xts")
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
print(g_stock_return)
g_date <- xts(g_stock_return)
install.packages("xts")
library("xts")
g_stock_sel<-g_stock[,6]
g_stock_sel
g_stock_return<-diff(log(g_stock_sel))
g_stock_return
print(g_stock_return)
g_date <- xts(g_stock_return)
g_date
write.csv(g_date, file = "forecast_2.csv", row.names = FALSE)
write.csv(g_date, file = "forecast_3.csv", row.names = FALSE)
g_stock_return<-diff(log(g_stock_sel))
final <- g_stock_return$date
final
setwd("C:\\SUTD\\UROP\\UROP_ScrapingTrafficData\\24.02.20 Activity Plan ML\\TripSample")
set.seed(1234)
trip_OD <- read.csv("trip_OD random sample 2 (10,000).csv")
# trip_OD only consists of 10,000 random data points
# Because R cannot process 40,000 datapoints due to computational limitations
head(trip_OD)
# ================================
#       K MEANS CLUSTERING
# ================================
# Step 1: Choosing the optimal K (the optimal number of clusters)
if (!require("factoextra")) {
install.packages("factoextra")
}
library(factoextra)
fviz_nbclust(trip_OD, kmeans, method = "wss") # Elbow Method
fviz_nbclust(trip_OD, kmeans, method = "silhouette") # Silhouette Method
# Setting K=4
kmeans.result <- kmeans(trip_OD, 4)
kmeans.result
kmeans.result$tot.withinss
# Setting K=14
kmeans.result <- kmeans(trip_OD, 14)
kmeans.result
kmeans.result$tot.withinss
# REMOVING SEVERAL VARIABLES
trip_OD_filtered <- trip_OD[,6:8]
head(trip_OD_filtered)
fviz_nbclust(trip_OD_filtered, kmeans, method = "wss") # Elbow Method
fviz_nbclust(trip_OD_filtered, kmeans, method = "silhouette") # Silhouette Method
# Setting K=4
kmeans4.result <- kmeans(trip_OD_filtered, 4)
kmeans4.result
kmeans4.result$tot.withinss
# Setting K=14
kmeans14.result <- kmeans(trip_OD_filtered, 14)
kmeans14.result
kmeans14.result$tot.withinss
kmeans4.result$tot.withinss
kmeans14.result$tot.withinss
# FOR LOOP
for (i in 11:20) {
# print("==================")
# print(paste("Executing for K=", i))
# print("==================")
# print(i)
kmeans.result <- NULL
kmeans.result <- kmeans(trip_OD_filtered, i)
print(kmeans.result)
# print(kmeans.result$size)
# print(kmeans.result$centers)
# print(kmeans.result$tot.withinss)
}
source("C:/SUTD/UROP/UROP_ScrapingTrafficData/24.02.20 Activity Plan ML/TripSample/trip_OD K-clustering.R")
kmeans.result <- kmeans(trip_OD_filtered, 14)
print(kmeans.result)
# Setting K=14
kmeans.result <- kmeans(trip_OD, 14)
kmeans.result
kmeans.result$tot.withinss
